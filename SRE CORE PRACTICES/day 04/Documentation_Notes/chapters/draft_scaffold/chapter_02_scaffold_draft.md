# Chapter 2: Traces Fundamentals - Following the Transaction Journey

## Panel 1: What Is a Trace? The Digital Footprint of Transactions
**Scene Description**: A banking operations center where an SRE team is gathered around a large display showing a visualization of a single payment transaction flowing through multiple systems. The visualization resembles a timeline with branches, showing how a customer's money transfer request moves from the mobile app through authentication, fraud checks, core banking, and finally to settlement systems. Different colored nodes represent different services, with connecting lines showing the path and timing of the request.

### Teaching Narrative
A trace represents the complete journey of a transaction or request as it travels through distributed systems, capturing every step from initiation to completion. Unlike traditional monitoring that presents isolated snapshots of individual components, traces provide the "story" of how transactions move through your architecture. In banking systems, where a single customer operation like a wire transfer might interact with dozens of microservices, traces act as digital breadcrumbs that connect these interactions into a coherent journey. This end-to-end visibility transforms troubleshooting from disconnected guesswork to evidence-based investigation, allowing teams to follow the exact path a transaction took, identify where it slowed down or failed, and understand dependencies between services that impact customer experience.

## Panel 2: Spans and Parent-Child Relationships: The Building Blocks of Traces
**Scene Description**: A close-up view of a banking analyst examining the detailed structure of a trace for an international payment. The screen shows nested boxes representing different spans, with the outermost box labeled "International Payment Processing" containing smaller boxes for "Authentication," "Fraud Check," "Currency Conversion," and "Settlement." Each span shows its duration, with a particularly long duration highlighted for the "Currency Conversion" span. Lines connect the spans showing their parent-child relationships.

### Teaching Narrative
Spans are the fundamental building blocks of traces, representing discrete units of work within a transaction's journey. Each span captures a specific operation—like validating a customer's identity, checking for fraudulent activity, or posting a debit entry—with crucial metadata including start time, duration, service name, and outcome. The parent-child relationships between spans reveal the causal connections between operations, showing not just what happened but in what order and which operations triggered others. This hierarchical structure provides critical context in complex banking systems where understanding dependencies is essential for reliability. When a foreign exchange transaction fails, spans reveal whether it was due to the authentication service timing out before validation could complete, the currency conversion API returning an error, or the core banking system rejecting the transaction—distinctions impossible to make with traditional monitoring tools.

## Panel 3: Context Propagation: Connecting the Dots Across Services
**Scene Description**: The scene shows a split-screen view of two banking engineers troubleshooting. On the left, an engineer without distributed tracing frantically searches through logs from different systems, trying to piece together related events with no common identifier. On the right, an SRE using distributed tracing easily follows a transaction using trace context identifiers that link activities across multiple service boundaries. The right screen shows how trace IDs and span IDs are automatically propagated from service to service, maintaining the connection between distributed operations.

### Teaching Narrative
Context propagation is the magic that transforms isolated service logs into connected transaction journeys. As requests move between services in a distributed banking system, trace context—including trace identifiers, parent span references, and customer metadata—must follow the request across network boundaries. This propagation enables the correlation of activities across dozens of independent systems into a single, coherent view of a customer's transaction. Without proper context propagation, a funds transfer moving from mobile banking through authentication, fraud detection, core banking, and partner bank systems would appear as disconnected events in separate logs, making it nearly impossible to reconstruct the complete journey. Effective context propagation preserves causality across system boundaries, allowing SREs to understand actual transaction flows rather than making educated guesses about how services interact.

## Panel 4: Instrumentation Approaches: Making Systems Traceable
**Scene Description**: A banking platform team is in the midst of a modernization project. Engineers are shown implementing different instrumentation approaches across their systems. Some newer microservices use auto-instrumentation with library agents, while legacy mainframe systems have manual trace point insertion. Middleware components show sidecar proxies capturing trace data without code changes. A whiteboard in the background shows the coverage map of which systems are instrumented and which still need work.

### Teaching Narrative
Instrumentation is how we make invisible system interactions visible through traces. In complex banking environments with hundreds of services spanning modern cloud platforms and legacy mainframes, different instrumentation approaches are necessary. Automatic instrumentation leverages agents and frameworks to capture trace data with minimal code changes—ideal for rapid implementation across modern services. Manual instrumentation requires explicit code additions but offers precise control over what gets traced and what business context is included—essential for critical transaction flows where details matter. Middleware-based approaches like service meshes can capture trace data without modifying applications, making them valuable for legacy systems where code changes are risky or impossible. The right instrumentation strategy balances coverage, detail, and implementation effort, prioritizing critical customer journeys to ensure visibility where it matters most while minimizing performance overhead.

## Panel 5: Trace Sampling: Managing Data Volume Without Losing Insight
**Scene Description**: An SRE team is configuring a trace sampling strategy during the end-of-month processing period for a large bank. A dashboard shows millions of transactions being processed with only a subset being fully traced. One screen displays different sampling rules: 100% sampling for high-value transactions and error cases, 50% for new product features, and 5% for routine, healthy transactions. A team member is pointing to a specific high-value customer journey that was automatically captured in full detail despite the sampling.

### Teaching Narrative
Trace sampling addresses the fundamental challenge of data volume in high-transaction banking environments where capturing every trace would overwhelm storage and analysis capabilities. Strategic sampling allows teams to collect representative traces while ensuring critical transactions are never missed. Head-based sampling decides whether to trace a transaction at its entry point—simple but potentially missing important error cases that develop later in the journey. Tail-based sampling makes decisions after transactions complete, capturing complete traces for interesting cases like errors or slow performance but requiring temporary storage of all trace data. Banking systems demand intelligent sampling that considers business context—ensuring 100% visibility for high-value client transactions, regulatory processes, or newly deployed features while sampling routine operations at lower rates. Effective sampling strategies balance technical limitations with business priorities, ensuring you have the trace data when and where it matters most.

## Panel 6: From Traces to Insights: Asking the Right Questions
**Scene Description**: A war room during a banking incident response. The team has moved past the initial panic and is now systematically analyzing trace data. Screens display various trace visualizations and queries. One analyst is filtering traces by duration to find the slowest transactions, another is comparing successful versus failed transfers to spot pattern differences, and a third is examining trace timelines before and after a deployment to identify what changed. Their focused approach is yielding clear patterns that point to a specific service degradation after a recent configuration change.

### Teaching Narrative
Collecting traces is just the beginning—the real value comes from extracting actionable insights through systematic analysis. Trace data transforms incident response from reactive guesswork to evidence-based investigation by enabling precise questions: Which services contribute most to overall latency? Where do failed transactions differ from successful ones? What changed between normal operation and the current degraded state? When customer-reported issues don't align with monitoring alerts, traces provide ground truth by showing actual user experiences. Beyond incidents, regular trace analysis builds institutional knowledge about system behavior, reveals hidden dependencies, and identifies optimization opportunities before they impact customers. The disciplined practice of asking consistent questions across traces—comparing performance across regions, customer segments, or transaction types—transforms isolated observations into patterns that drive both immediate fixes and long-term reliability improvements.